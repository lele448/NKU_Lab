#include <iostream>
#include <fstream>
#include <string>
#include <pthread.h>
#include <windows.h>
#include <iomanip>
#include <vector>

using namespace std;

int numthread =20; // 线程数量

//线程函数参数结构体:
typedef struct {
    int t_id; // 线程 id
    int* EE;  // 被消元行
    int* ER;  // 消元子
    int COL;  // 矩阵的列数
    int eeROW; // 被消元行的个数
    int erROW; // 消元子的个数
    int* flag; // 标记各个首非零消元子存在与否
    int N;    // 每行的int数
    int startRow; // 起始行
    int endRow;   // 结束行
} threadParam_t;

pthread_mutex_t mutex;

void* threadFunc1(void* param) {
    threadParam_t* p = (threadParam_t*)param;
    int t_id = p->t_id;
    int* EE = p->EE;
    int* ER = p->ER;
    int COL = p->COL;
    int eeROW = p->eeROW;
    int erROW = p->erROW;
    int* flag = p->flag;
    int N = p->N;
    int startRow = p->startRow;
    int endRow = p->endRow;

    for (int i = startRow; i < endRow; ++i) {
        int byte = 0;
        int bit = 0;
        while (true) {
            while (byte < N&& EE[i * N + byte] == 0) {
                byte++;
                bit = 0;
            }
            if (byte >= N) {
                break;
            }
            int temp = EE[i * N + byte] << bit;
            while (temp >= 0) {
                bit++;
                temp <<= 1;
            }
            pthread_mutex_lock(&mutex);
            int& isExist = flag[COL - 1 - (byte << 5) - bit];
            if (isExist != 0) {
                int* er = isExist > 0 ? &ER[(isExist - 1) * N] : &EE[~isExist * N];
                pthread_mutex_unlock(&mutex);
                for (int j = 0; j < N; j++) {
                    EE[i * N + j] ^= er[j];
                }
            }
            else {
                isExist = ~i;
                pthread_mutex_unlock(&mutex);
                break;
            }
        }
    }
    pthread_exit(NULL);
    return NULL;
}

// 多线程算法:
bool Pthread1(int selection) {
    // selection 决定读取哪个文件
    string Folders[] = { "1_130_22_8", "2_254_106_53", "3_562_170_53", "4_1011_539_263", "5_2362_1226_453",
 "6_3799_2759_1953","7_8399_6375_4535", "8_23045_18748_14325","9_37960_29304_14921","10_43577_39477_54274","11_85401_5724_756" };
    struct Size {
        int a;
        int b;
        int c; // 分别为矩阵列数，消元子个数和被消元行个数
    } fileSize[] = { {130, 22, 8}, {254, 106, 53}, {562, 170, 53}, {1011, 539, 262}, {2362, 1226, 453},
    {3799, 2759, 1953},{8399, 6375, 4535},{23045,18748,14325},{37960,29304,14921},{43577,39477,54274},{85401,5724,756} };

    ifstream erFile;
    ifstream eeFile;
    erFile.open(Folders[selection] + "/1.txt", std::ios::binary); // 消元子文件
    eeFile.open(Folders[selection] + "/2.txt", std::ios::binary); // 被消元行文件
    ofstream resFile(Folders[selection] + "/result.txt", ios::trunc); // 结果回写文件

    int COL = fileSize[selection].a;
    int erROW = fileSize[selection].b;
    int eeROW = fileSize[selection].c;
    int N = (COL + 31) / 32;

    vector<int> ER(erROW * N, 0);
    vector<int> EE(eeROW * N, 0);
    vector<int> flag(COL, 0);

    // 读取消元子:
    for (int i = 0; i < erROW; i++) {
        int col;
        char ch = ' ';
        erFile >> col;
        int r = COL - 1 - col;
        ER[i * N + (r >> 5)] = 1 << (31 - (r & 31));
        erFile.get(ch);
        flag[col] = i + 1;
        while (erFile.peek() != '\r' && erFile.peek() != '\n') {
            erFile >> col;
            int diff = COL - 1 - col;
            ER[i * N + (diff >> 5)] += 1 << (31 - (diff & 31));
            erFile.get(ch);
        }
    }

    // 读取被消元行:
    for (int i = 0; i < eeROW; i++) {
        int col;
        char ch = ' ';
        while (eeFile.peek() != '\r' && eeFile.peek() != '\n') {
            eeFile >> col;
            int diff = COL - 1 - col;
            EE[i * N + (diff >> 5)] += 1 << (31 - (diff & 31));
            eeFile.get(ch);
        }
        eeFile.get(ch);
    }

    pthread_mutex_init(&mutex, NULL);

    pthread_t* handles = new pthread_t[numthread]; // 创建Handle
    threadParam_t* param = new threadParam_t[numthread]; // 创建对应的线程数据结构

    int rowsPerThread = (eeROW + numthread - 1) / numthread; // 每个线程处理的行数

    for (int t_id = 0; t_id < numthread; t_id++) {
        param[t_id].t_id = t_id;
        param[t_id].EE = EE.data();
        param[t_id].ER = ER.data();
        param[t_id].COL = COL;
        param[t_id].eeROW = eeROW;
        param[t_id].erROW = erROW;
        param[t_id].flag = flag.data();
        param[t_id].N = N;
        param[t_id].startRow = t_id * rowsPerThread;
        param[t_id].endRow = min((t_id + 1) * rowsPerThread, eeROW);
    }

    // 创建线程
    for (int t_id = 0; t_id < numthread; t_id++)
        pthread_create(&handles[t_id], NULL, threadFunc1, (void*)&param[t_id]);

    // 主线程挂起等待所有的工作线程完成此轮消去工作
    for (int t_id = 0; t_id < numthread; t_id++)
        pthread_join(handles[t_id], NULL);

    pthread_mutex_destroy(&mutex);

    // 将得到的结果写回到文件中
    for (int i = 0; i < eeROW; i++) {
        int count = COL - 1;
        for (int j = 0; j < N; j++) {
            int dense = EE[i * N + j];
            for (int k = 0; k < 32; k++) {
                if (dense == 0) {
                    break;
                }
                else if (dense < 0) {
                    resFile << count - k << ' ';
                }
                dense <<= 1;
            }
            count -= 32;
        }
        resFile << '\n';
    }

    delete[] handles;
    delete[] param;

    return true;
}

void* threadFunc(void* param) {
    threadParam_t* p = (threadParam_t*)param;
    int t_id = p->t_id;
    int* EE = p->EE;
    int* ER = p->ER;
    int COL = p->COL;
    int eeROW = p->eeROW;
    int erROW = p->erROW;
    int* flag = p->flag;
    int N = p->N;

    for (int i = t_id; i < eeROW; i += numthread) {
        int byte = 0;
        int bit = 0;
        while (true) {
            while (byte < N&& EE[i * N + byte] == 0) {
                byte++;
                bit = 0;
            }
            if (byte >= N) {
                break;
            }
            int temp = EE[i * N + byte] << bit;
            while (temp >= 0) {
                bit++;
                temp <<= 1;
            }
            int& isExist = flag[COL - 1 - (byte << 5) - bit];
            if (!isExist == 0) {
                int* er = isExist > 0 ? &ER[(isExist - 1) * N] : &EE[~isExist * N];
                for (int j = 0; j < N; j++) {
                    EE[i * N + j] ^= er[j];
                }
            }
            else {
                isExist = ~i;
                break;
            }
        }
    }
    pthread_exit(NULL);
    return NULL;
}

//多线程算法:
bool Pthread(int selection) {
    //selection 决定读取哪个文件
    string Folders[] = { "1_130_22_8", "2_254_106_53", "3_562_170_53", "4_1011_539_263", "5_2362_1226_453",
 "6_3799_2759_1953","7_8399_6375_4535", "8_23045_18748_14325","9_37960_29304_14921","10_43577_39477_54274","11_85401_5724_756" };
    struct Size {
        int a;
        int b;
        int c; // 分别为矩阵列数，消元子个数和被消元行个数
    } fileSize[] = { {130, 22, 8}, {254, 106, 53}, {562, 170, 53}, {1011, 539, 262}, {2362, 1226, 453},
    {3799, 2759, 1953},{8399, 6375, 4535},{23045,18748,14325},{37960,29304,14921},{43577,39477,54274},{85401,5724,756} };

    ifstream erFile;
    ifstream eeFile;
    erFile.open(Folders[selection] + "/1.txt", std::ios::binary); // 消元子文件
    eeFile.open(Folders[selection] + "/2.txt", std::ios::binary); // 被消元行文件
    ofstream resFile(Folders[selection] + "/result.txt", ios::trunc); // 结果回写文件

    int COL = fileSize[selection].a;
    int erROW = fileSize[selection].b;
    int eeROW = fileSize[selection].c;
    int N = (COL + 31) / 32;

    vector<int> ER(erROW * N, 0);
    vector<int> EE(eeROW * N, 0);
    vector<int> flag(COL, 0);

    //读取消元子:
    for (int i = 0; i < erROW; i++) {
        int col;
        char ch = ' ';
        erFile >> col;
        int r = COL - 1 - col;
        ER[i * N + (r >> 5)] = 1 << (31 - (r & 31));
        erFile.get(ch);
        flag[col] = i + 1;
        while (erFile.peek() != '\r' && erFile.peek() != '\n') {
            erFile >> col;
            int diff = COL - 1 - col;
            ER[i * N + (diff >> 5)] += 1 << (31 - (diff & 31));
            erFile.get(ch);
        }
    }

    //读取被消元行:
    for (int i = 0; i < eeROW; i++) {
        int col;
        char ch = ' ';
        while (eeFile.peek() != '\r' && eeFile.peek() != '\n') {
            eeFile >> col;
            int diff = COL - 1 - col;
            EE[i * N + (diff >> 5)] += 1 << (31 - (diff & 31));
            eeFile.get(ch);
        }
        eeFile.get(ch);
    }

    pthread_t* handles = new pthread_t[numthread]; // 创建Handle
    threadParam_t* param = new threadParam_t[numthread]; // 创建对应的线程数据结构

    for (int t_id = 0; t_id < numthread; t_id++) {
        param[t_id].t_id = t_id;
        param[t_id].EE = EE.data();
        param[t_id].ER = ER.data();
        param[t_id].COL = COL;
        param[t_id].eeROW = eeROW;
        param[t_id].erROW = erROW;
        param[t_id].flag = flag.data();
        param[t_id].N = N;
    }

    // 创建线程
    for (int t_id = 0; t_id < numthread; t_id++)
        pthread_create(&handles[t_id], NULL, threadFunc, (void*)&param[t_id]);

    // 主线程挂起等待所有的工作线程完成此轮消去工作
    for (int t_id = 0; t_id < numthread; t_id++)
        pthread_join(handles[t_id], NULL);

    // 将得到的结果写回到文件中
    for (int i = 0; i < eeROW; i++) {
        int count = COL - 1;
        for (int j = 0; j < N; j++) {
            int dense = EE[i * N + j];
            for (int k = 0; k < 32; k++) {
                if (dense == 0) {
                    break;
                }
                else if (dense < 0) {
                    resFile << count - k << ' ';
                }
                dense <<= 1;
            }
            count -= 32;
        }
        resFile << '\n';
    }

    delete[] handles;
    delete[] param;

    return true;
}

//单线程算法:
bool Single_thread(int selection) {
    //selection 决定读取哪个文件
    string Folders[] = { "1_130_22_8", "2_254_106_53", "3_562_170_53", "4_1011_539_263", "5_2362_1226_453",
"6_3799_2759_1953","7_8399_6375_4535", "8_23045_18748_14325","9_37960_29304_14921","10_43577_39477_54274","11_85401_5724_756" };
    struct Size {
        int a;
        int b;
        int c; // 分别为矩阵列数，消元子个数和被消元行个数
    } fileSize[] = { {130, 22, 8}, {254, 106, 53}, {562, 170, 53}, {1011, 539, 262}, {2362, 1226, 453},
    {3799, 2759, 1953},{8399, 6375, 4535},{23045,18748,14325},{37960,29304,14921},{43577,39477,54274},{85401,5724,756} };

    ifstream erFile;
    ifstream eeFile;
    erFile.open(Folders[selection] + "/1.txt", std::ios::binary); // 消元子文件
    eeFile.open(Folders[selection] + "/2.txt", std::ios::binary); // 被消元行文件
    ofstream resFile(Folders[selection] + "/result.txt", ios::trunc); // 结果回写文件

    int COL = fileSize[selection].a;
    int erROW = fileSize[selection].b;
    int eeROW = fileSize[selection].c;
    int N = (COL + 31) / 32;

    vector<int> ER(erROW * N, 0);
    vector<int> EE(eeROW * N, 0);
    vector<int> flag(COL, 0);

    //读取消元子:
    for (int i = 0; i < erROW; i++) {
        int col;
        char ch = ' ';
        erFile >> col;
        int r = COL - 1 - col;
        ER[i * N + (r >> 5)] = 1 << (31 - (r & 31));
        erFile.get(ch);
        flag[col] = i + 1;
        while (erFile.peek() != '\r' && erFile.peek() != '\n') {
            erFile >> col;
            int diff = COL - 1 - col;
            ER[i * N + (diff >> 5)] += 1 << (31 - (diff & 31));
            erFile.get(ch);
        }
    }

    //读取被消元行:
    for (int i = 0; i < eeROW; i++) {
        int col;
        char ch = ' ';
        while (eeFile.peek() != '\r' && eeFile.peek() != '\n') {
            eeFile >> col;
            int diff = COL - 1 - col;
            EE[i * N + (diff >> 5)] += 1 << (31 - (diff & 31));
            eeFile.get(ch);
        }
        eeFile.get(ch);
    }

    for (int i = 0; i < eeROW; i++) {
        int byte = 0;
        int bit = 0;
        while (true) {
            while (byte < N&& EE[i * N + byte] == 0) {
                byte++;
                bit = 0;
            }
            if (byte >= N) {
                break;
            }
            int temp = EE[i * N + byte] << bit;
            while (temp >= 0) {
                bit++;
                temp <<= 1;
            }
            int& isExist = flag[COL - 1 - (byte << 5) - bit];
            if (!isExist == 0) {
                int* er = isExist > 0 ? &ER[(isExist - 1) * N] : &EE[~isExist * N];
                for (int j = 0; j < N; j++) {
                    EE[i * N + j] ^= er[j];
                }
            }
            else {
                isExist = ~i;
                break;
            }
        }
    }

    // 将得到的结果写回到文件中
    for (int i = 0; i < eeROW; i++) {
        int count = COL - 1;
        for (int j = 0; j < N; j++) {
            int dense = EE[i * N + j];
            for (int k = 0; k < 32; k++) {
                if (dense == 0) {
                    break;
                }
                else if (dense < 0) {
                    resFile << count - k << ' ';
                }
                dense <<= 1;
            }
            count -= 32;
        }
        resFile << '\n';
    }

    return true;
}

int main() {
    int counter1;
    int counter2; // 用于记录单线程和多线程算法在1秒内执行的次数
    long long head, tail, freq;
    long long head2, tail2, freq2;
    long long head3, tail3, freq3;
    // 获取计时频率
    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    cout.flags(ios::left);

    for (int i = 7; i <= 7; i += 1) { // 遍历文件:
        QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
        QueryPerformanceCounter((LARGE_INTEGER*)&head);
        Single_thread(i);
        QueryPerformanceCounter((LARGE_INTEGER*)&tail);

        float time1 = ((tail - head) * 1000.0 / freq);

        QueryPerformanceFrequency((LARGE_INTEGER*)&freq2);
        QueryPerformanceCounter((LARGE_INTEGER*)&head2);
        Pthread(i);
        QueryPerformanceCounter((LARGE_INTEGER*)&tail2);

        float time2 = ((tail2 - head2) * 1000.0 / freq2);



        cout << fixed << setprecision(6);
        cout << "线程数:" << numthread << endl;
        cout<< time1 << endl;
        cout  << time2 << endl;
      //  cout << time3 << endl;
        cout << endl;
    }
    return 0;
}

